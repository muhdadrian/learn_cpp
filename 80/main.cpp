// Introduction to temporary objects

// A temporary object (also sometimes called an anonymous object) is an unnamed object that is used to hold a value that is only needed for a short period of time. Temporary objects are generated by the compiler when they are needed.

// There are many different ways that temporary values can be created, but here’s a common one:

#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored?

	return 0;
}

// In the above program, the function getValueFromUser() returns the value stored in local variable input back to the caller. Because input will be destroyed at the end of the function, the caller receives a copy of the value so that it has a value it can use even after input is destroyed.

// But where is the value that is copied back to the caller stored? We haven’t defined any variables in main(). The answer is that the return value is stored in a temporary object. This temporary object is then passed to std::cout to be printed.

// Key insight: Return by value returns a temporary object (that holds a copy of the return value) to the caller.

// Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier).

// Temporary objects are destroyed at the end of the full expression in which they are created. This means temporary objects are always destroyed before the next statement executes.

/*
In our example above, the temporary object created to hold the return value of getValueFromUser() is destroyed after std::cout << getValueFromUser() << '\n' executes.

In the case where a temporary object is used to initialize a variable, the initialization happens before the destruction of the temporary.

In modern C++ (especially since C++17), the compiler has many tricks to avoid generating temporaries where previously it would have needed to. For example, when we use a return value to initialize a variable, this would normally result in the creation of a temporary holding the return value, and then using the temporary to initialize the variable. However, in modern C++, the compiler will often skip creating the temporary and just initialize the variable directly with the return value.

Similarly, in the above example, since the return value of getValueFromUser() is immediately output, the compiler can skip creation and destruction of the temporary in main(), and use the return value of getValueFromUser() to directly initialize the parameter of operator<<.
 */
